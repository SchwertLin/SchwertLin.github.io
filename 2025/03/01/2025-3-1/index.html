<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="author" content="Schwertlilien"/><meta name="keyword"/><meta name="description" content="Mathe-CVPR-2016 Mathe, Stefan, Aleksis Pirinen, and Cristian Sminchisescu. “Reinforcement learning for visual object detection.” Proceedings of the IEEE conference on computer vision and pattern recog">
<meta property="og:type" content="article">
<meta property="og:title" content="2025-3-1-Mathe-CVPR-2016">
<meta property="og:url" content="http://example.com/2025/03/01/2025-3-1/index.html">
<meta property="og:site_name" content="Schwertlilien">
<meta property="og:description" content="Mathe-CVPR-2016 Mathe, Stefan, Aleksis Pirinen, and Cristian Sminchisescu. “Reinforcement learning for visual object detection.” Proceedings of the IEEE conference on computer vision and pattern recog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/SchwertLin/Pic@main/img/image-20250301224942435.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/SchwertLin/Pic@main/img/image-20250302111017235.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/SchwertLin/Pic@main/img/image-20250302111032378.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/SchwertLin/Pic@main/img/image-20250302161410823.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/SchwertLin/Pic@main/img/image-20250302164543367.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/SchwertLin/Pic@main/img/image-20250302164637503.png">
<meta property="article:published_time" content="2025-03-01T03:41:41.000Z">
<meta property="article:modified_time" content="2025-03-02T08:48:57.000Z">
<meta property="article:author" content="Schwertlilien">
<meta property="article:tag" content="论文阅读">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/SchwertLin/Pic@main/img/image-20250301224942435.png"><title>2025-3-1-Mathe-CVPR-2016 - Schwertlilien - -----personal blog-----</title><link rel="shortcut icon" href="/img/site-icon.png">
<link rel="stylesheet" href="/css/style.css" id="dm-light">


<link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.4.2/css/all.min.css">

<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
<meta name="generator" content="Hexo 7.3.0"></head><body><header><div class="top-nav" ondblclick="scrollToTop()"><div class="nav-info"><div class="nav-icon"><img id="nav-icon" src="/img/site-icon.png"/></div><div class="nav-title"><a id="nav-title" href="/" title="主页">Schwertlilien</a></div></div><div class="nav-ribbon"><div class="top-menu-expanded"><a class="top-menu-item" href="/archives"><span>归档</span></a><a class="top-menu-item" href="/categories"><span>分类</span></a><a class="top-menu-item" href="/tags"><span>标签</span></a><a class="top-menu-item" href="/about"><span>关于</span></a></div><div class="top-search" onclick="toggleSearchWindow()"><div id="top-search-btn" title="搜索"><i class="icon fa-solid fa-magnifying-glass"></i><span>搜索</span></div></div><div id="top-menu-btn" onclick="openTopMenu()" title="打开菜单"><i class="fa-solid fa-bars fa-lg"></i></div></div></div></header><div id="top-menu-hidden"><div class="menu-hidden-content"><div class="menu-hidden-nav"><a class="menu-hidden-item" href="/archives"><i class="fa-solid fa-box-archive fa-sm"></i><span>归档</span></a><a class="menu-hidden-item" href="/categories"><i class="fa-regular fa-folder-open fa-sm"></i><span>分类</span></a><a class="menu-hidden-item" href="/tags"><i class="fa-solid fa-tags fa-sm"></i><span>标签</span></a><a class="menu-hidden-item" href="/about"><i class="fa-solid fa-paw fa-sm"></i><span>关于</span></a></div></div><div class="menu-hidden-blank" onclick="closeTopMenu()"></div></div>
<div class="blog-info"><div class="blog-pic"><img id="blog-pic" src="/img/site-icon.png"/></div><div class="blog-title"><i class="fa-solid fa-paw fa-2xs fa-rotate-by"></i><span>Schwertlilien</span><i class="fa-solid fa-paw fa-2xs fa-rotate-by"></i></div><div class="blog-desc">As a recoder: notes and ideas.</div></div><div class="main"><div class="main-content"><article class="post"><div class="post-title"><h1><i class="fa-solid fa-paw"></i>2025-3-1-Mathe-CVPR-2016</h1></div><div class="post-info"><div class="post-info-first-line"><div class="post-date"><i class="icon fa-regular fa-calendar-plus" title="发布日期"></i><time class="publish-time">2025-03-01</time><i class="icon fa-regular fa-calendar-check" title="更新日期"></i><time class="update-time">2025-03-02</time></div>

<div class="post-tags"><i class="icon fa-solid fa-tags" title="标签"></i><a class="post-tag" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">论文阅读</a></div></div><div class="post-info-second-line"><div class="post-copyright"><i class="icon fa-brands fa-creative-commons" title="版权声明"></i><span>版权声明: </span><a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh-hans" title="CC BY-NC-ND 4.0">署名-非商业性使用-禁止演绎 4.0</a></div>
<div class="post-word-count"><i class="icon fa-solid fa-pen-to-square"></i><span>全文约6.4K字</span></div><div class="pageview-post"><i class="icon fa-regular fa-eye"></i><span id="busuanzi_container_page_pv">阅读次数: <span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner"></i></span></span></div></div></div><div class="post-content"><h1 id="Mathe-CVPR-2016"><a href="#Mathe-CVPR-2016" class="headerlink" title="Mathe-CVPR-2016"></a>Mathe-CVPR-2016</h1><blockquote>
<p>Mathe, Stefan, Aleksis Pirinen, and Cristian Sminchisescu. “Reinforcement learning for visual object detection.” <em>Proceedings of the IEEE conference on computer vision and pattern recognition</em>. 2016.</p>
</blockquote>
<p>一种应用最广泛的视觉目标检测策略是基于穷举空间假设搜索。虽然像滑动窗口这样的方法已经成功和有效了很多年，但它们仍然是蛮力的，独立于图像内容和被搜索的视觉类别。在本文中，我们提出了原则性的顺序模型，该模型积累了在一小组图像位置收集的证据，以便有效地检测视觉对象。</p>
<p>通过将<strong>顺序搜索制定为搜索策略（包括停止条件）</strong>的强化学习，我们的完全可训练模型可以明确地平衡每个类别，特别是探索的冲突目标-采样更多的图像区域以获得更好的准确性-和开发-在充分确信目标位置时有效地停止搜索。该方法具有通用性，适用于任何探测器响应函数。我们在PASCAL VOC 2012目标检测测试集中报告了令人鼓舞的结果，表明所提出的方法比滑动窗口方法实现了近两个数量级的加速。</p>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>检测=一组假设的目标位置上最大化置信度函数。</p>
<p>置信度可以在监督或是弱监督设置中学习。</p>
<p>在滑动窗口公式中，假设集由大量矩形窗口组成，并通过穷举搜索解决最大化问题。由于这个过程在实践中通常过于昂贵，因此已经提出了许多方法来加速它，从利用置信度函数属性的方法到建议方法或级联技术。</p>
<p>相比之下，生物系统的搜索模式可以被描述为“扫视和注视”[17]，这表明只有一小部分场景位置被关注，以便在目标位置得到较高的置信度。</p>
<p>暂时不考虑效率（只探索了图像的少数区域）和生物合理性，上面这种方式通过有序地整合证据，以一种有原则的方式，正式推导出能够最佳地平衡效率和准确性的数学模型。挑战在于能够在<strong>延迟奖励</strong>的情况下运作，<strong>这就排除了对每一步的监督</strong>。</p>
<p>同时，避免需要完全预先指定环境，这对于视觉场景来说是不可能的-考虑到图像和视觉对象类别的复杂性，模型应该得到有效的训练。</p>
<blockquote>
<p>扫视和注视=Transformer的注意力机制</p>
<p>“同时，避免需要<strong>完全</strong>预先指定环境，这对于视觉场景来说是不可能的-考虑到图像和视觉对象类别的复杂性，模型应该得到有效的训练。”我没搞懂在说什么。</p>
<p>At the same time, avoid the need to completely pre-specify the environment, which for visual scenes would be impossible– given the complexity of images and visual object categories, the models should be effectively trained.</p>
</blockquote>
<p>通过<strong>将顺序搜索定义为类别和图像依赖搜索策略（包括停止条件）的强化学习</strong>，在这项工作中，我们开发了完全可训练的方法，可以明确地平衡探索（采样更多图像区域以提高准确性）和开发（在对目标位置有足够信心时有效地停止搜索）的冲突目标。该方法是通用的，适用于任何检测器响应函数，并且可以学习特定于图像和视觉类别的搜索策略和停止条件。在具有挑战性的PASCAL VOC2012目标检测基准测试中，实现了比滑动窗口方法两个数量级的加速。</p>
<p>Related Work：2016年的感觉没必要看了。</p>
<h2 id="Problem-Formulation"><a href="#Problem-Formulation" class="headerlink" title="Problem Formulation"></a>Problem Formulation</h2><p>对于给定的input img，将<strong>动作检测</strong>表示为最大化置信函数$f_c:R\rightarrow\mathbb{R}$</p>
<script type="math/tex; mode=display">
r^*=\arg \max_{r\in R}f_c(r)</script><p>$R$：图像区域集，被定义在粗略的边界框级别，也可以定义在使用建议生成方法（RP）获得的更精细的自由图像区域级别。</p>
<p>因为$f_c$的成本高，所以为解决此问题提出了有效搜索策略。</p>
<h3 id="序列模型"><a href="#序列模型" class="headerlink" title="序列模型"></a>序列模型</h3><p><strong>基于强化学习的序列检测器</strong>：在每个时间步，模型可以根据观测区域的历史$H_t$（算法1）终止搜索（$d_t = 1$），并产生一个置信度为$c_t$的检测假设$b_t$，这会获得奖励$A_t^d$用于衡量检测质量。否则，从未选择区域的集合$\frac{H_t }{E_t}$中选择一个证据区域$e_t$，并用于预测下一个固定位置$z_t$。观察到$z_t$附近所有区域的集合$O_t$（算法2），并收到负奖励$A_t^f$，反映了提取这些区域特征的计算成本$r_t$。</p>
<p><img src="https://cdn.jsdelivr.net/gh/SchwertLin/Pic@main/img/image-20250301224942435.png" alt="image-20250301224942435"></p>
<p>用于图像探索的最优序列模型的关键组成部分给定一组图像区域R，以集合$B =\{1，…，|R|\}$（以$|·|$为集合基数）为$R$的下标index。</p>
<p>置信度函数：</p>
<script type="math/tex; mode=display">
r^*=\arg \max_{r\in R}f_c(r)\\
f_c(r)=\theta^{T}_c q(r)</script><p>参数为$\theta_c$，特征提取器$q：R→\mathbb{R}^m$。</p>
<p><strong>该模型的目标是通过最少次数评估这两个计算代价高昂的函数来定位目标</strong>。</p>
<p>在检测序列的每个时间步$t$ （除了最后一步），我们的模型会基于当前状态$S_t$生成固定动作$A_t^f$。每个$A_t^f$决定<strong>一个</strong>候选目标位置。此外，模型还得到一组观测$O_t$:此候选目标位置附近的一组图像区域的观测。我们只对此区域进行置信度检测和特征提取。然后这个观测被用来更新状态$S_t$，并总结所有过去的观察和行动。</p>
<p>当收集到足够的图像信息时，模型发出一个特殊的done动作，表示它已经确定了检测目标的位置。完成动作与检测目标边界框$b_t$和检测置信度$c_t$相关联。该模型具有一组可训练参数$\theta = (\theta_c,\theta_d,\theta_e,\theta_p，\sum_p,\sigma_c)$，分别控制检测器响应置信度、停止准则、图像区域相对于目标位置的信息量、最有可能下一个固定点的图像位置及其方差，以及与模型输出相关的置信度$c_t$的方差。</p>
<p>每个固定动作$A^f_t$都可以潜在地减少定位检测目标的不确定性，但由于需要将一组观测值$O_t$整合到状态中，因此与计算成本相关。我们模型的目标是平衡信息收集（固定操作 $A^f_t$）与正确定位目标（完成操作 $A^d_t$）的需求之间的冲突。</p>
<h3 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h3><p>现在我们开始详细描述我们模型的行为(A)、状态(S)、观察(O)和决策过程。模型组件如上图所示，搜索模式的几个示例如图2所示。</p>
<p><strong>状态</strong>：模型的状态表示为一个包含三个元素的元组：观测区域历史$H_t$，选定证据区域历史$E_t$和固定历史$F_t$。这个元组$S_t = (H_t,E_t,F_t)$总结了自搜索序列开始以来的观测和动作的历史。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$S_t$</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>观测区域历史 $H_t$</td>
<td>在每个时间步$t$，模型跟踪迄今观测到的图像区域的历史$H_t≤B$。置信函数$f_c$仅对这些区域进行评估，并用于决定何时终止搜索。历史$H_t$也被模型用来决定下一步要关注的可能位置，因为$H_t$为搜索提供了上下文信息。</td>
</tr>
<tr>
<td>选择的证据区域历史 $E_t$</td>
<td>模型根据观测历史中的证据区域$e_t\in H_t$,来决定下一个要固定的位置。证据区域被视为提供指示目标位置的必要上下文。然而，为了鼓励搜索过程中的多样性，每个区域最多只能被用作一次证据。因此，该模型对迄今选取的区域的集合$E_t$作追踪，并始终从集合${H_t}  \setminus{E_t}$中选取证据区域。</td>
</tr>
<tr>
<td>固定历史 $F_t$</td>
<td>每个时间步长$t$的观测区域集合，取决于过去固定位置的历史$F_t$。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>动作</strong>：模型中的动作表示为元组。有两种动作，由它们的第一个元素来区分，它可以是两个离散的符号之一：固定或完成。模型的动作空间由所有固定元组和完成元组的并集组成，即$A = A^f∪A^d$。</p>
<ul>
<li>固定动作表示为三元素元组$A^f_t = (Fixate,e_t,z_t)$，其中$e_t\in B$表示证据区域的索引，$z_t\in\mathbb{R}^2$表示下一次固定的图像坐标。</li>
<li>完成的动作表示为$A^d_t = (Done,b_t,c_t)$，其中$b_t\in B$是表示检测输出的区域的索引，$c_t\in \mathbb{R}$表示检测置信度。</li>
</ul>
<p><strong>观测</strong>：在注视动作之后，注视位置$z_t$附近的图像区域集合$O_t$被观察到。为了定义这个邻域，我们在固定中心$z_t$周围使用半径为$T_R$的圆形区域。如果一个像素落在与$z_t$相关的区域内，我们说它在时间$t$是固定的。为了使区域$r$在时刻$t$被观测到，它从像素级别上看，大部分$h(r)$必须在当前或之前的步骤中被固定。</p>
<script type="math/tex; mode=display">
h(r) = \frac{|{x\in r|(∃)z\in F_t, \|z - x\|_2≤T_R}|}{|r|} \\
O_t = {i\in B|h(r_i)≥T_F}</script><p>其中$F_t = \{z_1，…，z_t\}$是模型在时间步长为$t$之前固定位置的历史，$T_F$是控制观察段中固定像素的最小比例的阈值。</p>
<h3 id="随机策略"><a href="#随机策略" class="headerlink" title="随机策略"></a>随机策略</h3><p>模型根据当前状态决定下一步采取的行动。它的<strong>随机决策策略</strong>$\pi_{\theta}(S_t,A_t)$分三个阶段进行，每个阶段都有自己的一组学习参数。模型评估<strong>是否终止搜索（终止决策）</strong>。</p>
<ul>
<li>positive: done</li>
<li>negative: fixate</li>
</ul>
<p>终止决策：基于当前状态$S_t$，模型可以在任意给定的时间步长决定终止搜索，并产生检测结果（而不是使用特设的终止策略）。</p>
<blockquote>
<p>例如: 预设的固定数量 fixations（搜索位置,search locations），模型使用一个学习的决策函数来平衡检测置信度和计算负载。</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>检测置信度</th>
<th>计算负载</th>
</tr>
</thead>
<tbody>
<tr>
<td>如果模型已经观察到一个区域，该区域被认为包含高置信度的检测目标，它可能会决定提前终止搜索。</td>
<td>检测器的运行成本：迄今为止执行的置信函数评估次数+搜索策略评估的数量</td>
</tr>
<tr>
<td>为了捕捉这方面，我们计算了迄今为止观测到的P区域上的最大置信度：$asmax {f_c (r_i)}\in H_t$</td>
<td>迄今为止执行的置信函数评估次数: 与当前时间步长t观测区域的$</td>
<td>Ht</td>
<td>\setminus</td>
<td>R</td>
<td>$之比成正比</td>
</tr>
<tr>
<td>对于任何集合$X$和平滑元参数$\alpha$: $asmax(X) = \frac{\sum _{x\in X} xe^{\alpha x}}{\sum _{x\in X} e^{\alpha x}}$</td>
<td>搜索策略评估的数量: 由于策略在每个时间步长评估一次，因此该成本与时间步长t成正比</td>
</tr>
</tbody>
</table>
</div>
<script type="math/tex; mode=display">
\begin{align}
&\pi_{\theta}(A_t=(done,b_t,c_t)|S_t)=p_{\theta}(d_t=1|S_t)p_{\theta}(b_t|d_t=1,S_t)p_{\theta}(c_t|d_t=1,S_t,b_t)\\
&\pi_{\theta}(A_t=(fixate,e_t,z_t)|S_t)=p_{\theta}(d_t=0|S_t)p_{\theta}(e_t|S_t)p_{\theta}(z_t|S_t,e_t)
\end{align}</script><p>上面公式完全指定了模型策略，这两个公式定义了所有可能动作的概率分布。注意，此策略在特征和参数上是高度（深度）非线性的。随机策略是由高度非线性预测拓扑上的高斯分布给出的。</p>
<p>现在来对上面各部分进行介绍：</p>
<h4 id="Done-Action策略"><a href="#Done-Action策略" class="headerlink" title="Done Action策略"></a>Done Action策略</h4><p>在终止（$d_t = 1$）时，模型从观测区域的集合$H_t$中输出一个边界框$b_t$，表示检测目标的位置，同时输出置信度分数$c_t$。我们使用一个softmax边界框选择准则，平滑度元参数为α。$\sigma_c\in \mathbb{R}$是控制置信度预测方差的模型参数。</p>
<script type="math/tex; mode=display">
\begin{align}
&\pi_{\theta}(A_t=(done,b_t,c_t)|S_t)=p_{\theta}(d_t=1|S_t)p_{\theta}(b_t|d_t=1,S_t)p_{\theta}(c_t|d_t=1,S_t,b_t)\\
&p_{\theta}(d_t=1|S_t)=\text{sigmoid}\left[\theta^T_d v(S_t)\right]\\
&p_{\theta}(b_t=k|d_t=1,S_t)=\frac{e^{\alpha f_c(r_k)}}{\sum_{i\in H_t}e^{\alpha f_c(r_i)}}\\
&p_{\theta}(c_t|d_t=1,S_t,b_t=k)=N(c_t|f_c(r_k),\sigma_c)\\
&v(S_t)=\begin{pmatrix}\text{asmax}(\{f_c(r_i)\}_{i\in H_t})&t&\frac{|H_t|}{|R|}&1\end{pmatrix}^T\in \mathbb{R}^4
\end{align}</script><h4 id="Fixate-Action策略"><a href="#Fixate-Action策略" class="headerlink" title="Fixate Action策略"></a>Fixate Action策略</h4><p>如果搜索未终止（$d_t = 0$），则模型从观察到的区域集中选择一个新的证据区域$e_t\in(H_t \setminus e_t)$，它认为该区域对目标位置有信息。我们定义了一个证据函数$f_e: B→\mathbb R, f_e(i) = \exp \left[\theta_e^T q(r_i)\right]$，用来评估图像区域i相对于目标位置的信息量，其中$\theta_e$是学习到的模型参数。</p>
<p>我们从证据函数定义的多项分布中选择区域$e_t$，这些分布在之前步骤中未选择的图像区域的集合$H_t\setminusE_t$上：</p>
<script type="math/tex; mode=display">
\begin{align}
&\pi_{\theta}(A_t=(fixate,e_t,z_t)|S_t)=p_{\theta}(d_t=0|S_t)p_{\theta}(e_t|S_t)p_{\theta}(z_t|S_t,e_t)\\
&p_{\theta}(e_t|S_t) = \frac{f_e(et)}{\sum_{i\in H_t}f_e(i)}\\
&p_{\theta}(z_t|S_t,e_t)= N(\cdot|f_p(e_t),\Delta(e_t)^T\Sigma_p\Delta(e_t))\\
&f_p(e_t)=\Delta(e_t)\theta_p^Tq(e_t)+\mu(e_t)\\
&\Delta(e_t)=\text{diag}\left(\frac{x_1(e_t)-x_2(e_t)}{2}\right)\\
&\mu(e_t)=\frac{x_1(e_t)+x_2(e_t)}{2}
\end{align}</script><p>其中$\Sigma_p$是一个习得的协方差矩阵，控制注视的传播，高斯中心$f_p(e_t)$基于证据区域特征$q(r_{e_t})$与习得参数$\theta_p$。</p>
<h3 id="推理与学习"><a href="#推理与学习" class="headerlink" title="推理与学习"></a>推理与学习</h3><p><strong>推理</strong>：通过对策略$\pi_{\theta}(A_t|S_t)$的重复采样来进行推理，直到得到一个done动作（算法1:策略采样算法）。根据动作$A_t$ （Algorithm2）更新每一步的状态$S_t$。当搜索完成后，生成区域和置信度并返回到检测器输出。</p>
<p><strong>学习</strong>：给出一组图像，表示为区域集$B_j$，以及旨在获得在目标位置最大置信度函数。为了符号的简单性，在不损失一般性的情况下，我们将考虑包含$n$（可能为0）个检测目标和相应的实际真实区域$\{g_i\}^n_{i=1}$的图片。我们希望找到模型参数$\theta=(\theta_c,\theta_d,\theta_e,\theta_p,\Sigma_p,\sigma_c)$，基于上一步($d_t=1$)的检测目标区域$b_t$和置信度$c_t$，最大化目标检测的准确度，以及最小化候选区域评估的数量。</p>
<h4 id="Policy-sampling-algorithm（策略采样算法）"><a href="#Policy-sampling-algorithm（策略采样算法）" class="headerlink" title="Policy sampling algorithm（策略采样算法）"></a>Policy sampling algorithm（策略采样算法）</h4><p><img src="https://cdn.jsdelivr.net/gh/SchwertLin/Pic@main/img/image-20250302111017235.png" alt="image-20250302111017235"></p>
<ol>
<li><strong>输入</strong>： 该算法的输入是状态 $S_t = (H_t, E_t, F_t)$，这里 $H_t$、$E_t$ 和 $F_t$ 可能代表不同的状态组成部分，比如历史信息、环境相关信息等。 </li>
<li><strong>核心步骤</strong>：    <ol>
<li>首先根据公式(4)和(5)从概率分布 $p(d_t|S_t)$ 中采样得到 $d_t$ 。    </li>
<li>如果 $d_t = 1$ ，则进一步分别根据公式(6)从 $p(b_t|S_t, d_t)$ 采样 $b_t$ ，根据公式(7)从 $p(c_t|S_t, d_t, b_t)$ 采样 $c_t$ ，最后返回动作 $A_t = (done, b_t, c_t)$ ，这里 “done” 可能是表示一个终止状态相关的标识 。    </li>
<li>如果 $d_t \neq 1$ ，则根据公式(9)从 $p(e_t|S_t, d_t)$ 采样 $e_t$ ，再根据公式(12)从 $p(z_t|S_t, d_t, e_t)$ 采样 $z_t$ ，最后返回动作 $A_t = (fixate, e_t, z_t)$ 。</li>
</ol>
</li>
<li><strong>作用</strong>：这个算法主要是根据当前状态 $S_t$ ，通过一系列的概率采样来确定要执行的动作 $A_t$ ，不同的条件分支会产生不同形式的动作。 </li>
</ol>
<h4 id="State-transition-algorithm（状态转移算法）"><a href="#State-transition-algorithm（状态转移算法）" class="headerlink" title="State transition algorithm（状态转移算法）"></a>State transition algorithm（状态转移算法）</h4><p><img src="https://cdn.jsdelivr.net/gh/SchwertLin/Pic@main/img/image-20250302111032378.png" alt="image-20250302111032378"></p>
<ol>
<li><strong>输入</strong>： 输入当前状态 $S_t = (H_t, E_t, F_t)$ 和动作 $A_t = (fixate, e_t, z_t)$ 。 </li>
<li><strong>核心步骤</strong>：   <ol>
<li>第一步根据公式确定 $O_t$ ，其中 $B$ 可能是一个集合，$h(r_i)$ 是某种函数计算， $T_F$ 是一个阈值 。    </li>
<li>然后更新 $H_{t + 1}$ 为 $H_t$ 和 $O_t$ 的并集；更新 $E_{t + 1}$ 为 $E_t$ 和 $e_t$ 的并集；更新 $F_{t + 1}$ 为 $F_t$ 和 $z_t$ 的并集 。    </li>
<li>最后返回更新后的状态 $S_{t + 1} = (H_{t + 1}, E_{t + 1}, F_{t + 1})$ 。 </li>
</ol>
</li>
<li><strong>作用</strong>：该算法描述了在给定当前状态和执行的动作后，如何更新状态到下一个时刻的状态，即定义了状态转移的规则。 </li>
</ol>
<h4 id="奖励函数"><a href="#奖励函数" class="headerlink" title="奖励函数"></a>奖励函数</h4><p>为了捕捉这种权衡，并避免明确地指导模型如何实现它，我们将训练目标作为延迟奖励，作为典型的强化学习设置。我们的奖励函数对检测位置和最终状态的置信度很敏感，并且会对每个区域的评估产生惩罚。</p>
<script type="math/tex; mode=display">
r_t(S_t, A_t; \{g_i\}_{i = 1}^n)=
\begin{cases}
-\beta \cdot |O_t \setminus H_t| & \text{if } d_t = 0 \\
\text{sigmoid}(c_t) \cdot [\max_{i = 1, n} \text{iou}(g_i, r_{b_t})] & \text{if } d_t = 1 \land n > 0 \\
-\text{sigmoid}(c_t) & \text{if } d_t = 1 \land n = 0
\end{cases}</script><p>其中 $\text{iou}(\cdot, \cdot)$ 是区域上的交并比函数，$\beta$ 是模型为每次置信度函数评估支付的惩罚系数 。 </p>
<p><strong>奖励函数 $r_t(S_t, A_t; \{g_i\}_{i = 1}^n)$ 的定义</strong>：    </p>
<ol>
<li>输入包括当前状态 $S_t$ 、动作 $A_t$ 以及一组目标区域 $\{g_i\}_{i = 1}^n$ 。  </li>
<li>当 $d_t = 0$ 时，奖励为 $-\beta \cdot |O_t \setminus H_t|$ 。这里 $\beta$ 是一个惩罚系数，$|O_t \setminus H_t|$ 表示新观察到的区域集合 $O_t$ 与之前区域集合 $H_t$ 的差集的大小，这意味着每进行一次置信度函数评估，模型会受到一定的惩罚，该惩罚与新观察区域的计算成本相关。    </li>
<li>当 $d_t = 1$ 且 $n &gt; 0$ 时，奖励为 $\text{sigmoid}(c_t) \cdot [\max_{i = 1, n} \text{iou}(g_i, r_{b_t})]$ 。其中 $\text{sigmoid}(c_t)$ 是对 $c_t$ 应用 sigmoid 函数，$\text{iou}(g_i, r_{b_t})$ 是区域 $g_i$ 和 $r_{b_t}$ 的交并比（Intersection over Union），该分支表示在目标存在（$n &gt; 0$）且执行 “done” 动作（$d_t = 1$）时，模型的奖励与它的置信度和真实区域的重叠程度成正比。   </li>
<li>当 $d_t = 1$ 且 $n = 0$ 时，奖励为 $-\text{sigmoid}(c_t)$ ，此时忽略位置信息，模型的置信度越小，奖励越高。 </li>
</ol>
<p>在训练期间，通过最大化训练集上的期望奖励函数来优化模型。 </p>
<script type="math/tex; mode=display">
F(\theta)=\mathbb{E}_{p_\theta(s)}\left[\sum^{|s|}_{t=1}r_t\right]-\frac \lambda 2 \theta^T\theta</script><p>$\mathbb{E}_{p_{\theta}(s)}$ 表示基于参数 $\theta$ 的策略 $p_{\theta}(s)$ 的期望。$s = ((S_0, A_0),\ldots,(S_k, A_k),\ldots)$ 代表一个可变长度的状态序列，从初始状态 $S_0 = (H_0, E_0, F_0)$ 开始，通过运行前面提到的算法1和算法2采样得到。$\sum_{t = 1}^{|s|} r_t$ 是状态序列中每一步 $t$ 的奖励 $r_t$ 的总和。$-\frac{\lambda}{2} \theta^{\top} \theta$ 是L2正则化项，$\lambda$ 是正则化系数，用于防止模型过拟合。初始状态中的 $H_0$ 设为通过固定图像中心观察到的片段集合，$E_0$ 和 $F_0$ 都设为空集 $\emptyset$ 。</p>
<p>对于一张图像，期望奖励的梯度 $\nabla_{\theta}F(\theta)$ 可以近似为:</p>
<script type="math/tex; mode=display">
\nabla_{\theta}F(\theta)=\frac{1}{M}\sum_{i = 1}^{M}\sum_{t = 1}^{|s^i|}\nabla_{\theta}\log\pi_{\theta}(A_t^i|S_t^i)\left[\sum_{t = 1}^{|s^i|} r_t^i\right]+\lambda\theta</script><p>其中 $M$ 是采样序列的总数，$s^i = ((S_0^i, A_0^i),\ldots,(S_k^i, A_k^i),\ldots)$ 是第 $i$ 个采样得到的<strong>状态 - 动作序列</strong>(State-Action)，$r_t^i$ 是该序列中第 $t$ 步的奖励。$\nabla_{\theta}\log\pi_{\theta}(A_t^i|S_t^i)$ 与基于当前状态 $S_t^i$ 采取动作 $A_t^i$ 的策略的对数梯度有关。</p>
<p><strong>模型训练过程</strong>： 训练这个序列模型需要计算期望奖励及其梯度（参考上式）。对于每张图像，要模拟模型直到搜索终止，也就是在状态 - 动作空间中生成序列。  </p>
<p><strong>动作采样过程</strong>： 在每个时间步 $t$ ，根据算法1从策略中采样一个动作 $A_t$ 。</p>
<ul>
<li>具体来说，首先从分布 $p_{\theta}(d_t|S_t)$ 中采样来决定搜索是否终止（如果 $d_t = 1$ ，表示 “done” 动作）。</li>
<li>如果终止，就分别从 $p_{\theta}(b_t|d_t = 1, S_t)$ 和 $p_{\theta}(c_t|d_t = 1, S_t)$ 中采样输出区域索引 $b_t$ 和置信度 $c_t$ 。</li>
<li>如果不终止（$d_t = 0$ ），则从 $p_{\theta}(e_t|d_t = 0, S_t)$ 中采样证据区域 $e_t$ ，再从 $p_{\theta}(z_t|d_t = 0, e_t, S_t)$ 中采样下一个注视位置 $z_t$ 。  </li>
</ul>
<p><strong>模型状态更新</strong>： 最后，按照算法2更新模型的状态。通过多次采样序列，用于估计期望，进而训练模型。    </p>
<p><img src="https://cdn.jsdelivr.net/gh/SchwertLin/Pic@main/img/image-20250302161410823.png" alt="image-20250302161410823"></p>
<h2 id="Expr"><a href="#Expr" class="headerlink" title="Expr"></a>Expr</h2><p>在这部分，作者通过实验验证他们提出的搜索方法在具有挑战性的Pascal VOC 2012目标检测基准上的效果。使用的区域空间由特定算法提取的所有片段组成，为保证通用性和一致性，选择CPMC算法的片段，因其与检测目标的映射准确度较高。</p>
<h3 id="实验流程"><a href="#实验流程" class="headerlink" title="实验流程"></a>实验流程</h3><ol>
<li><strong>对比模型及方法</strong>：为量化不同标准检测模型的性能，分别使用滑动窗口搜索（SW）、对CPMC区域提议集进行穷举搜索（RP），以及作者提出的基于序列强化学习的搜索模型（RL） 。 </li>
<li><strong>提议生成</strong>：运行公开实现的算法获取RP假设；对于SW基线，通过迭代不同尺寸和纵横比的窗口来生成假设。  </li>
<li><strong>特征提取</strong>：特征提取器采用Krizhevsky等人的深度神经网络。对每个区域提议，获取其内容特征，并结合边界框尺寸和纵横比，得到8204维的最终特征向量。作者为简化模型，使用通用特征提取器训练线性SVM模型，而非进一步优化深度神经网络。 </li>
<li><strong>训练序列强化学习检测器</strong>：在Pascal VOC 2012训练集上找到使期望奖励最大化的最优参数向量θ 。因参数数量多易过拟合，先使用线性SVM预训练初始化参数。 </li>
<li><strong>初始化与参数设置</strong>：通过对图像区域到真实边界框中心的回归初始化参数；对其他参数进行均匀随机采样并优化。在Pascal VOC验证集上验证观察模型参数，实际中这些参数的敏感度不高。</li>
</ol>
<h3 id="计算效率和准确性"><a href="#计算效率和准确性" class="headerlink" title="计算效率和准确性"></a>计算效率和准确性</h3><p>作者提出的序列检测器准确性接近滑动窗口基线，但速度快70多倍，还考虑了RP算法的开销。此外，将该方法与其他高效搜索方法对比时，虽然<strong>代码不可用</strong>，但可从特征表示差异等方面进行综合考量。</p>
<h3 id="定性分析"><a href="#定性分析" class="headerlink" title="定性分析"></a>定性分析</h3><p>搜索序列长度与图像中目标位置相关。若目标靠近图像中心，模型可能在首次注视后就终止搜索；若目标在周边，则会继续搜索。</p>
<p>证据区域（如图2中绿色部分）可从三个方面引导搜索：</p>
<ol>
<li>提供目标位置线索；</li>
<li>包含目标从而让模型定位；</li>
<li>在目标过大时，通过子部分引导搜索，直到目标完全包含在观察集中 。    </li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/SchwertLin/Pic@main/img/image-20250302164543367.png" alt="image-20250302164543367"></p>
<p>模型生成的固定位置$z_t$（橙色圆圈）序列，以及相应的证据区域$e_t$（绿色框），以及最终检测到的边界框$b_t$（黄色）。如果通过第一个中心固定（第二行第一个图像）找到目标，则模型可以提前终止搜索。当目标尚未被发现时，通常会利用不包含目标的区域来引导搜索到新的有希望的位置（例如，街道提供了寻找公共汽车的上下文）。当一个小目标位于一个更宽的区域（例如树上的鸟）时，该模型使用更宽的区域作为上下文线索，以一种从粗到细的方式找到目标。</p>
<p>类似地，涉及多个探索性固定点的精细到粗搜索策略用于提供观察大型目标（例如飞机）所需的中央凹覆盖。定量结果见表:</p>
<p><img src="https://cdn.jsdelivr.net/gh/SchwertLin/Pic@main/img/image-20250302164637503.png" alt="image-20250302164637503"></p>
<h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2>

	<div class="row">
    <embed src="https://cdn.jsdelivr.net/gh/SchwertLin/Pic/Pdf/Mathe_CVPR_2016_paper.pdf" width="100%" height="550" type="application/pdf">
	</div>



</div><div class="post-end"><div class="post-prev"><a href="/2025/03/02/2025-3-2/" title="上一篇文章"><i class="fa-solid fa-chevron-left fa-lg"></i></a></div><div class="post-next"><a href="/2025/02/26/2025-2-26/" title="下一篇文章"><i class="fa-solid fa-chevron-right fa-lg"></i></a></div></div></article><div class="comment" id="comment"><script src="https://giscus.app/client.js" data-repo="SchwertLin/SwertLin_Blog_Comment" data-repo-id="R_kgDONXjrCQ" data-category="Announcements" data-category-id="DIC_kwDONXjrCc4Cky9X" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async="async"></script></div><div id="post-toc"><aside class="toc-aside"><div class="toc-title"><span><i class="fa-solid fa-paw"></i>目录</span></div><div class="toc-container" id="toc-body"><ol class="toc-content"><li class="toc-content-item toc-content-level-1"><a class="toc-content-link" href="#Mathe-CVPR-2016"><span class="toc-content-number">1.</span> <span class="toc-content-text">Mathe-CVPR-2016</span></a><ol class="toc-content-child"><li class="toc-content-item toc-content-level-2"><a class="toc-content-link" href="#Intro"><span class="toc-content-number">1.1.</span> <span class="toc-content-text">Intro</span></a></li><li class="toc-content-item toc-content-level-2"><a class="toc-content-link" href="#Problem-Formulation"><span class="toc-content-number">1.2.</span> <span class="toc-content-text">Problem Formulation</span></a><ol class="toc-content-child"><li class="toc-content-item toc-content-level-3"><a class="toc-content-link" href="#%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B"><span class="toc-content-number">1.2.1.</span> <span class="toc-content-text">序列模型</span></a></li><li class="toc-content-item toc-content-level-3"><a class="toc-content-link" href="#%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%84"><span class="toc-content-number">1.2.2.</span> <span class="toc-content-text">模型结构</span></a></li><li class="toc-content-item toc-content-level-3"><a class="toc-content-link" href="#%E9%9A%8F%E6%9C%BA%E7%AD%96%E7%95%A5"><span class="toc-content-number">1.2.3.</span> <span class="toc-content-text">随机策略</span></a><ol class="toc-content-child"><li class="toc-content-item toc-content-level-4"><a class="toc-content-link" href="#Done-Action%E7%AD%96%E7%95%A5"><span class="toc-content-number">1.2.3.1.</span> <span class="toc-content-text">Done Action策略</span></a></li><li class="toc-content-item toc-content-level-4"><a class="toc-content-link" href="#Fixate-Action%E7%AD%96%E7%95%A5"><span class="toc-content-number">1.2.3.2.</span> <span class="toc-content-text">Fixate Action策略</span></a></li></ol></li><li class="toc-content-item toc-content-level-3"><a class="toc-content-link" href="#%E6%8E%A8%E7%90%86%E4%B8%8E%E5%AD%A6%E4%B9%A0"><span class="toc-content-number">1.2.4.</span> <span class="toc-content-text">推理与学习</span></a><ol class="toc-content-child"><li class="toc-content-item toc-content-level-4"><a class="toc-content-link" href="#Policy-sampling-algorithm%EF%BC%88%E7%AD%96%E7%95%A5%E9%87%87%E6%A0%B7%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-content-number">1.2.4.1.</span> <span class="toc-content-text">Policy sampling algorithm（策略采样算法）</span></a></li><li class="toc-content-item toc-content-level-4"><a class="toc-content-link" href="#State-transition-algorithm%EF%BC%88%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-content-number">1.2.4.2.</span> <span class="toc-content-text">State transition algorithm（状态转移算法）</span></a></li><li class="toc-content-item toc-content-level-4"><a class="toc-content-link" href="#%E5%A5%96%E5%8A%B1%E5%87%BD%E6%95%B0"><span class="toc-content-number">1.2.4.3.</span> <span class="toc-content-text">奖励函数</span></a></li></ol></li></ol></li><li class="toc-content-item toc-content-level-2"><a class="toc-content-link" href="#Expr"><span class="toc-content-number">1.3.</span> <span class="toc-content-text">Expr</span></a><ol class="toc-content-child"><li class="toc-content-item toc-content-level-3"><a class="toc-content-link" href="#%E5%AE%9E%E9%AA%8C%E6%B5%81%E7%A8%8B"><span class="toc-content-number">1.3.1.</span> <span class="toc-content-text">实验流程</span></a></li><li class="toc-content-item toc-content-level-3"><a class="toc-content-link" href="#%E8%AE%A1%E7%AE%97%E6%95%88%E7%8E%87%E5%92%8C%E5%87%86%E7%A1%AE%E6%80%A7"><span class="toc-content-number">1.3.2.</span> <span class="toc-content-text">计算效率和准确性</span></a></li><li class="toc-content-item toc-content-level-3"><a class="toc-content-link" href="#%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-content-number">1.3.3.</span> <span class="toc-content-text">定性分析</span></a></li></ol></li><li class="toc-content-item toc-content-level-2"><a class="toc-content-link" href="#%E5%8E%9F%E6%96%87"><span class="toc-content-number">1.4.</span> <span class="toc-content-text">原文</span></a></li></ol></li></ol></div></aside><div class="toc-blank" onclick="tocToggle()"></div></div><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});
MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for(i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async="async"></script></div></div><div id="tool-bar"><div id="tool-bar-main"><div id="tool-toggle" onclick="toolToggle()" title="设置"><i class="fa-solid fa-gear"></i></div><div id="toc-toggle" onclick="tocToggle()" title="目录"><i class="fa-solid fa-list-ul"></i></div><div id="go-to-comment" onclick="gotoComment()" title="评论"><i class="fa-regular fa-message fa-flip-horizontal"></i></div><div id="back-to-top" onclick="scrollToTop()" title="返回顶部"><i class="fa-solid fa-chevron-up"></i></div></div><div id="tool-bar-more" style="display: none;"><div id="darkmode-switch" onclick="darkmodeSwitch()" title="深色模式"><i class="fa-solid fa-circle-half-stroke"></i></div><div id="font-size-increase" onclick="fontSizeIncrease()" title="放大字体"><i class="fa-solid fa-plus"></i></div><div id="font-size-decrease" onclick="fontSizeDecrease()" title="缩小字体"><i class="fa-solid fa-minus"></i></div></div></div><div id="search-panel"><div class="search-container"><div class="search-head"><div class="search-title"><span><i class="fa-solid fa-paw"></i>搜索</span></div><div class="search-close-btn" onclick="toggleSearchWindow()"><i class="fa-regular fa-circle-xmark"></i></div></div><div class="search-box"><i class="fa-solid fa-magnifying-glass"></i><input id="search-input" type="text" placeholder="请输入需要搜索的内容……" value=""/></div><div class="search-body"><div id="search-count">匹配结果数: </div><div id="search-result"></div><div id="search-result-empty">未搜索到匹配的文章。</div></div></div></div><footer><div class="footer-content"><div class="copyright-info"><i class="fa-regular fa-copyright fa-xs"></i><span>2022 - 2025 </span><a href="/about">Schwertlilien</a><i class="fa-solid fa-cat fa-sm"></i><span>Powered by </span><a href="https://hexo.io/" target="_blank">Hexo</a><span> &amp; </span><a href="https://github.com/chanwj/hexo-theme-meow" target="_blank" title="v2.1.0">Theme Meow</a></div><div class="pageview-site"><span id="busuanzi_container_site_pv">总访问量 : <span id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner"></i></span></span><span id="busuanzi_container_site_uv">总访客数 : <span id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner"></i></span></span></div></div></footer>
<script>const GLOBAL_CONFIG = {
  comment: { theme: 'preferred_color_scheme'}
}
</script>
<script src="/js/third-party/darkmode.js"></script>
<script>var options = {
  dark: '/css/darkmode.css',
  startAt: '24:00',
  endAt: '06:00',
  checkSystemScheme: 'false',
  saveOnToggle: 'true'
};
var darkMode = new DarkMode(options);
// change comment theme synchronously 同步修改评论区主题
if (darkMode.getMode() == "dark" && (true || true)) {
  if (document.getElementById('comment')) {
    document.getElementById('comment').getElementsByTagName('script')[0].setAttribute('data-theme', 'noborder_dark');
  }
}
</script><script>if (localStorage.getItem('font-size')) {
  document.querySelector('.post-content').style.fontSize = localStorage.getItem('font-size') + 'px';
}
</script>
<script src="/js/theme/tool-bar.js"></script>


<script src="/js/theme/menu.js"></script>


<script src="/js/third-party/clipboard.min.js"></script>


<script src="/js/theme/copy.js"></script>
<script>copyCode();
</script>
<script src="/js/jquery-3.7.1.min.js"></script>


<script src="/js/theme/search.js"></script>
<script>searchFunc('/search.xml', 'search-input', 'search-result');
</script></body></html>